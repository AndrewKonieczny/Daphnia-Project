----------------------------------------------------------------------
swimBoxPlot <- geom_boxplot(aes(fill = dose),outlier.shape = 1,
outlier.size = 1.5, notch = FALSE,
width = 1)
swimX_Lable <- xlab(expression(paste(
"A-68930 Concentration (",mu,M,")")))
swimY_Lable <- ylab(expression(paste(
"Swimming Force (",mu,N,")")))
swimTheme <- theme(legend.position="none")
swimDataPlot + swimBoxPlot + swimX_Lable + swimY_Lable + swimTheme
swimDataPlot <- ggplot(cleaned, aes(dose, activity))
swimBoxPlot <- geom_boxplot(aes(fill = dose),outlier.shape = 1,
outlier.size = 1.5, notch = FALSE,
width = 1)
swimX_Lable <- xlab(expression(paste(
"A-68930 Concentration (",mu,M,")")))
swimY_Lable <- ylab(expression(paste(
"Swimming Force (",mu,N,")")))
swimTheme <- theme(legend.position="none")
swimDataPlot + swimBoxPlot + swimX_Lable + swimY_Lable + swimTheme
swimDataPlot <- ggplot(cleaned, aes(dose, activity))
swimBoxPlot <- geom_boxplot(aes(fill = dose),outlier.shape = 1,
outlier.size = 1.5, notch = FALSE,
width = 1)
swimX_Lable <- xlab(expression(paste(
"A-68930 Concentration (",mu,M,")")))
swimY_Lable <- ylab(expression(paste(
"Swimming Force (",mu,N,")")))
swimTheme <- theme(legend.position="none")
swimDataPlot + swimBoxPlot + swimX_Lable + swimY_Lable + swimTheme
swimDataPlot <- ggplot(cleaned, aes(dose, activity))
swimBoxPlot <- geom_boxplot(aes(fill = dose),outlier.shape = 1,
outlier.size = 1.5, notch = FALSE,
width = 1)
swimX_Lable <- xlab(expression(paste(
"A-68930 Concentration (",mu,M,")")))
swimY_Lable <- ylab(expression(paste(
"Swimming Force (",mu,N,")")))
swimTheme <- theme(legend.position="none")
swimDataPlot + swimBoxPlot + swimX_Lable + swimY_Lable + swimTheme
cleaned <- read.csv("~/Documents/daphnialab/cleaned.csv")
cleaned$dose<-as.factor(cleaned$dose)
p <- ggplot(cleaned, aes(dose, activity))
p+stat_density(x=cleaned$activity,mapping = NULL, data = NULL, stat = "density", position = "identity", na.rm = FALSE,alpha=.2)+ggtitle('Activity by Dose')
p+stat_density(x=cleaned$activity,mapping = NULL, data = NULL, method = "density", position = "identity", na.rm = FALSE,alpha=.2)+ggtitle('Activity by Dose')
qplot(log(activity, base = exp(1)), data  =  cleaned,	facets	=	dose~., main = (expression(paste("A-68930 Concentration (",mu,M,")")))) + xlab(expression(paste("Swimming Force (",mu,N,")"))) + ylab("Bin Count")
qplot(activity,  data  =  cleaned, geom="density", facets	=	.~dose,main=(expression(paste("A-68930 Concentration (",mu,M,")"))))+xlab(expression(paste("Swimming Force (",mu,N,")")))+ylab("Density")
cleaned
200*0.0518
qplot(activity, data  =  cleaned,  facets	=	dose~., main = (expression(paste("A-68930 Concentration (",mu,M,")")))) + xlab(expression(paste("Swimming Force (",mu,N,")"))) + ylab("Bin Count")
qplot(log(activity*10^(-6), base = exp(1)), data  =  cleaned,	facets	=	dose~., main = (expression(paste("A-68930 Concentration (",mu,M,")")))) + xlab(expression(paste("Swimming Force ln(",mu,N,")"))) + ylab("Bin Count")
qplot(log((activity*10^(-6)), base = exp(1)), data  =  cleaned,	facets	=	dose~., main = (expression(paste("A-68930 Concentration (",mu,M,")")))) + xlab(expression(paste("Swimming Force ln(",mu,N,")"))) + ylab("Bin Count")
cleaned$activity[2]
qplot(log((activity), base = exp(1)), data  =  cleaned,	facets	=	dose~., main = (expression(paste("A-68930 Concentration (",mu,M,")")))) + xlab(expression(paste("Swimming Force ln(",mu,N,")"))) + ylab("Bin Count")
qplot(log((activity*C), base = exp(1)), data  =  cleaned,	facets	=	dose~., main = (expression(paste("A-68930 Concentration (",mu,M,")")))) + xlab(expression(paste("Swimming Force ln(",mu,N,")"))) + ylab("Bin Count")
summary(cleaned)
C <- as.numeric(coef(lsfit((Calibration$Disp),(Calibration$Force),
wt=NULL,intercept=0)))*10^6
a <- SwimReport(Controls, 2)
b <- SwimReport(Drug0.1uM, 2)
a <- SwimReport(Controls, 2)
b <- SwimReport(Drug0.1uM, 2)
c <- SwimReport(Drug1uM, 2)
d <- SwimReport(Drug10uM, 2)
e <- SwimReport(Drug100uM, 2)
activity <- c(a,b,c,d,e)*C
summary(activity)
summary(activity>20)
summary(activity>25)
hist(a)
summary(a*C)
summary(b*C)
summary(Calibration)
summary(activity*C>21)
summary(activity)
summary(activity>21)
maximumForceReportable <- max(Calibration$X)
maximumForceReportable
max(a)
a <- SwimReport(Controls, 2)*C
summary(a)
summary(a>maximumForceReportable)
a[!a>maximumForceReportable]
summary(a>maximumForceReportable)
?rm
a <- SwimReport(Controls, 2)*C
a[a>maximumForceReportable] <- NA
summary(a)
a[!is.na(a)]
a <- a[!is.na(a)]
summary(a)
a <- SwimReport(Controls, 2)*C
a <- a[a<maximumForceReportable]
summary(a)
a <- SwimReport(Controls, 2)*C
a <- a[a<maximumForceReportable]
b <- SwimReport(Drug0.1uM, 2)*C
b <- b[b<maximumForceReportable]
c <- SwimReport(Drug1uM, 2)*C
c <- c[c<maximumForceReportable]
d <- SwimReport(Drug10uM, 2)*C
d <- d[d<maximumForceReportable]
e <- SwimReport(Drug100uM, 2)*C
e <- e[e<maximumForceReportable]
activity <- c(a,b,c,d,e)
dose <- c(rep("0", length(a)),
rep("0.1", length(b)),
rep("1", length(c)),
rep("10", length(d)),
rep("100", length(e)))
require(ggplot2)
final <- as.data.frame(cbind(dose,activity))
write.csv(final, "~/Documents/daphnialab/cleaned.csv")
cleaned <- read.csv("~/Documents/daphnialab/cleaned.csv")
rm(list=setdiff(ls(), "cleaned"))
cleaned$dose<-as.factor(cleaned$dose)
p <- ggplot(cleaned, aes(dose, activity))
swimDataPlot <- ggplot(cleaned, aes(dose, activity))
swimBoxPlot <- geom_boxplot(aes(fill = dose),outlier.shape = 1,
outlier.size = 1.5, notch = FALSE,
width = 1)
swimX_Lable <- xlab(expression(paste(
"A-68930 Concentration (",mu,M,")")))
swimY_Lable <- ylab(expression(paste(
"Swimming Force (",mu,N,")")))
swimTheme <- theme(legend.position="none")
swimDataPlot + swimBoxPlot + swimX_Lable + swimY_Lable + swimTheme
Calibration <- read.csv(
"~/Documents/daphnialab/Analysed Raw Data/Concat/Calibration.csv",
header = TRUE)
Controls <- read.csv(
"~/Documents/daphnialab/Analysed Raw Data/Concat/Controls.csv",
header = TRUE)
Drug0.1uM <- read.csv(
"~/Documents/daphnialab/Analysed Raw Data/Concat/Drug0.1uM.csv",
header = TRUE)
Drug1uM <- read.csv(
"~/Documents/daphnialab/Analysed Raw Data/Concat/Drug1uM.csv",
header = TRUE)
Drug10uM <- read.csv(
"~/Documents/daphnialab/Analysed Raw Data/Concat/Drug10uM.csv",
header = TRUE)
Drug100uM <- read.csv(
"~/Documents/daphnialab/Analysed Raw Data/Concat/Drug100uM.csv",
header = TRUE)
C <- as.numeric(coef(lsfit((Calibration$Disp),(Calibration$Force),
wt=NULL,intercept=0)))*10^6
maximumForceReportable <- max(Calibration$X)
a <- SwimReport(Controls, 2)*C
a <- a[a<maximumForceReportable]
b <- SwimReport(Drug0.1uM, 2)*C
b <- b[b<maximumForceReportable]
c <- SwimReport(Drug1uM, 2)*C
c <- c[c<maximumForceReportable]
d <- SwimReport(Drug10uM, 2)*C
d <- d[d<maximumForceReportable]
e <- SwimReport(Drug100uM, 2)*C
e <- e[e<maximumForceReportable]
activity <- c(a,b,c,d,e)
dose <- c(rep("0", length(a)),
rep("0.1", length(b)),
rep("1", length(c)),
rep("10", length(d)),
rep("100", length(e)))
# To use this function, you need to import a .csv file of the raw
# ImageJ data. To prepare the .csv file, you need to take the
# individual animal observation periods and collect them into a single
# .csv file. Then, depending on how you concatinate the collected data
# you take note of what the interval is between individual animal
# observations is and put that value into the DataInterval position of
# thefunction. For example, if you have two observation periods and
# two animals in the same drug concentration, you may have recorded,
# using ImageJ, the ID, Area, X, Y, and Slice. If you recorded this
# information, in this order, you have an interval of 5 since you have
# 5 categories of data. Only the Area and X data are examined here.
# The ID has no meaning here and the Y displacements are minimal and
# add very little to the force measurements  being made. Slice only
# has importance when the time is needed for a time series analysis,
# which this script does not address. The output is an array of force
# measurements that can be compared at various drug concentrations.
# This script also removes the feeding oscilations (which is only
# important here because it skewes the mean force measuments).
SwimReport <- function(InputData,DataInterval)
{
# A simple difference function taking in an array and outputs an
# array of differences (final - initial)
dx <- function(x)
{
y   <- c(0,x[1:length(x)-1])
z   <- c(0,x[2:length(x)])
out <- z-y
return(out)
}
zero <- function(zeroInput, zeroColumn)
{
# 640 is the width of the image. This conversion is done to
# correct the x-y coordinate system.
numbers <- 640-data.matrix(zeroInput[zeroColumn])
# a 20% trimmed mean results in a better central fiber position
central <- mean(abs(dx(numbers)),na.rm=TRUE, trim = 0.2)
out     <- as.vector((numbers-central), mode = "numeric")
return(out)
}
area_dev <- function(areaInput, areaColumn)
{
g      <- data.matrix(areaInput[areaColumn])
z_area <- abs(g-mean(g,na.rm = TRUE))/sd(g,na.rm=TRUE)
# 'z_area' uses the trimmed mean to find the absolute value of the
# z-score for the fiber's area values, the z-score is then used to
# remove any valuses that deviate too far from the area's trimmed
# mean.
out    <- as.vector(ifelse(z_area<=2,1,NA), mode = "numeric")
return(out)
}
filter <- function(Input, Element, Interval)
{
col_zero <- (Element)*Interval
# The column to be entered into the zero() function
col_area <- (Element)*Interval-1
# The column to be intered into the area_dev() function
out <- as.vector(zero(Input, col_zero)*area_dev(Input,col_area),
mode = "numeric")
return(out)
}
# This function concatenates the different columns of X's
# The inputs:
#   Input = the raw .csv file,
#   Intervals = the number of columns for each filming period (if
#               there are two columns until the next filming period,
#               e.g. area and x, then the Intervals value is 2).
# The output:
#   An array of normalized distance values (units are in pixels) that
#   are concatinated together.
concat <- function(Inputs,Intervals)
{
final   <- NULL
Max     <- dim(Inputs)[2]/2
elementSequence <- seq(1,Max,1)
for (i in elementSequence)
{
final <- c(final,filter(Inputs,elementSequence[i],Intervals))
}
return(final)
}
# This function finds the max force values by removing values around a
# local maximum value. The input is the data to be filtered (preferably
# after being concatinated) with a bound that is simply the lower limit
# of which you want no values below it. The output is an array of the
# filtered data.
ForceFilter <- function(input,bound)
{
data  <- ifelse(input>=bound,input,0)
x     <- ifelse(is.na(data),0,data)
y     <- c(0,x[1:length(x)-1])
z     <- c(x[2:length(x)],0)
one   <- ifelse(x>y,1,NA)
two   <- ifelse(x>z,1,NA)
three <- one*two*x
four  <- ifelse(three==0,NA,three)
out   <- four[!is.na(four)]
return(out)
}
# Takes in input data, and goes therough a series of possible lower
# bounds to output an array of means.
lowerbounds <- function(input,MAX)
{
v     <- seq(0,MAX,1)
out   <- NULL
for(i in v)
{
out <- c(out,mean(ForceFilter(concat(input,2),i),na.rm=TRUE))
}
return(out)
}
# Using the 'second derivative' of the bound array to find where the
# difference between means (based on lower bound) has a rate of change
# less than 1. Using that lower bound, the function outputs the force
# data.
BestBound <- sum(ifelse(abs(dx(dx(lowerbounds(InputData,100))))>1,1,
0))+1
ForceData <- ForceFilter(concat(InputData,DataInterval),BestBound)
return(ForceData)
}
Calibration <- read.csv(
"~/Documents/daphnialab/Analysed Raw Data/Concat/Calibration.csv",
header = TRUE)
Controls <- read.csv(
"~/Documents/daphnialab/Analysed Raw Data/Concat/Controls.csv",
header = TRUE)
Drug0.1uM <- read.csv(
"~/Documents/daphnialab/Analysed Raw Data/Concat/Drug0.1uM.csv",
header = TRUE)
Drug1uM <- read.csv(
"~/Documents/daphnialab/Analysed Raw Data/Concat/Drug1uM.csv",
header = TRUE)
Drug10uM <- read.csv(
"~/Documents/daphnialab/Analysed Raw Data/Concat/Drug10uM.csv",
header = TRUE)
Drug100uM <- read.csv(
"~/Documents/daphnialab/Analysed Raw Data/Concat/Drug100uM.csv",
header = TRUE)
C <- as.numeric(coef(lsfit((Calibration$Disp),(Calibration$Force),
wt=NULL,intercept=0)))*10^6
maximumForceReportable <- max(Calibration$X)
a <- SwimReport(Controls, 2)*C
a <- a[a<maximumForceReportable]
b <- SwimReport(Drug0.1uM, 2)*C
b <- b[b<maximumForceReportable]
c <- SwimReport(Drug1uM, 2)*C
c <- c[c<maximumForceReportable]
d <- SwimReport(Drug10uM, 2)*C
d <- d[d<maximumForceReportable]
e <- SwimReport(Drug100uM, 2)*C
e <- e[e<maximumForceReportable]
activity <- c(a,b,c,d,e)
dose <- c(rep("0", length(a)),
rep("0.1", length(b)),
rep("1", length(c)),
rep("10", length(d)),
rep("100", length(e)))
summary(a)
summary(b)
summary(c)
# To use this function, you need to import a .csv file of the raw
# ImageJ data. To prepare the .csv file, you need to take the
# individual animal observation periods and collect them into a single
# .csv file. Then, depending on how you concatinate the collected data
# you take note of what the interval is between individual animal
# observations is and put that value into the DataInterval position of
# thefunction. For example, if you have two observation periods and
# two animals in the same drug concentration, you may have recorded,
# using ImageJ, the ID, Area, X, Y, and Slice. If you recorded this
# information, in this order, you have an interval of 5 since you have
# 5 categories of data. Only the Area and X data are examined here.
# The ID has no meaning here and the Y displacements are minimal and
# add very little to the force measurements  being made. Slice only
# has importance when the time is needed for a time series analysis,
# which this script does not address. The output is an array of force
# measurements that can be compared at various drug concentrations.
# This script also removes the feeding oscilations (which is only
# important here because it skewes the mean force measuments).
SwimReport <- function(InputData,DataInterval)
{
# A simple difference function taking in an array and outputs an
# array of differences (final - initial)
dx <- function(x)
{
y   <- c(0,x[1:length(x)-1])
z   <- c(0,x[2:length(x)])
out <- z-y
return(out)
}
zero <- function(zeroInput, zeroColumn)
{
# 640 is the width of the image. This conversion is done to
# correct the x-y coordinate system.
numbers <- 640-data.matrix(zeroInput[zeroColumn])
# a 20% trimmed mean results in a better central fiber position
central <- mean(ifelse(abs(dx(numbers))<20,numbers,NA),na.rm=TRUE, trim = 0.2)
out     <- as.vector((numbers-central), mode = "numeric")
return(out)
}
area_dev <- function(areaInput, areaColumn)
{
g      <- data.matrix(areaInput[areaColumn])
z_area <- abs(g-mean(g,na.rm = TRUE))/sd(g,na.rm=TRUE)
# 'z_area' uses the trimmed mean to find the absolute value of the
# z-score for the fiber's area values, the z-score is then used to
# remove any valuses that deviate too far from the area's trimmed
# mean.
out    <- as.vector(ifelse(z_area<=2,1,NA), mode = "numeric")
return(out)
}
filter <- function(Input, Element, Interval)
{
col_zero <- (Element)*Interval
# The column to be entered into the zero() function
col_area <- (Element)*Interval-1
# The column to be intered into the area_dev() function
out <- as.vector(zero(Input, col_zero)*area_dev(Input,col_area),
mode = "numeric")
return(out)
}
# This function concatenates the different columns of X's
# The inputs:
#   Input = the raw .csv file,
#   Intervals = the number of columns for each filming period (if
#               there are two columns until the next filming period,
#               e.g. area and x, then the Intervals value is 2).
# The output:
#   An array of normalized distance values (units are in pixels) that
#   are concatinated together.
concat <- function(Inputs,Intervals)
{
final   <- NULL
Max     <- dim(Inputs)[2]/2
elementSequence <- seq(1,Max,1)
for (i in elementSequence)
{
final <- c(final,filter(Inputs,elementSequence[i],Intervals))
}
return(final)
}
# This function finds the max force values by removing values around a
# local maximum value. The input is the data to be filtered (preferably
# after being concatinated) with a bound that is simply the lower limit
# of which you want no values below it. The output is an array of the
# filtered data.
ForceFilter <- function(input,bound)
{
data  <- ifelse(input>=bound,input,0)
x     <- ifelse(is.na(data),0,data)
y     <- c(0,x[1:length(x)-1])
z     <- c(x[2:length(x)],0)
one   <- ifelse(x>y,1,NA)
two   <- ifelse(x>z,1,NA)
three <- one*two*x
four  <- ifelse(three==0,NA,three)
out   <- four[!is.na(four)]
return(out)
}
# Takes in input data, and goes therough a series of possible lower
# bounds to output an array of means.
lowerbounds <- function(input,MAX)
{
v     <- seq(0,MAX,1)
out   <- NULL
for(i in v)
{
out <- c(out,mean(ForceFilter(concat(input,2),i),na.rm=TRUE))
}
return(out)
}
# Using the 'second derivative' of the bound array to find where the
# difference between means (based on lower bound) has a rate of change
# less than 1. Using that lower bound, the function outputs the force
# data.
BestBound <- sum(ifelse(abs(dx(dx(lowerbounds(InputData,100))))>1,1,
0))+1
ForceData <- ForceFilter(concat(InputData,DataInterval),BestBound)
return(ForceData)
}
Calibration <- read.csv(
"~/Documents/daphnialab/Analysed Raw Data/Concat/Calibration.csv",
header = TRUE)
Controls <- read.csv(
"~/Documents/daphnialab/Analysed Raw Data/Concat/Controls.csv",
header = TRUE)
Drug0.1uM <- read.csv(
"~/Documents/daphnialab/Analysed Raw Data/Concat/Drug0.1uM.csv",
header = TRUE)
Drug1uM <- read.csv(
"~/Documents/daphnialab/Analysed Raw Data/Concat/Drug1uM.csv",
header = TRUE)
Drug10uM <- read.csv(
"~/Documents/daphnialab/Analysed Raw Data/Concat/Drug10uM.csv",
header = TRUE)
Drug100uM <- read.csv(
"~/Documents/daphnialab/Analysed Raw Data/Concat/Drug100uM.csv",
header = TRUE)
C <- as.numeric(coef(lsfit((Calibration$Disp),(Calibration$Force),
wt=NULL,intercept=0)))*10^6
maximumForceReportable <- max(Calibration$X)
a <- SwimReport(Controls, 2)*C
a <- a[a<maximumForceReportable]
b <- SwimReport(Drug0.1uM, 2)*C
b <- b[b<maximumForceReportable]
c <- SwimReport(Drug1uM, 2)*C
c <- c[c<maximumForceReportable]
d <- SwimReport(Drug10uM, 2)*C
d <- d[d<maximumForceReportable]
e <- SwimReport(Drug100uM, 2)*C
e <- e[e<maximumForceReportable]
activity <- c(a,b,c,d,e)
dose <- c(rep("0", length(a)),
rep("0.1", length(b)),
rep("1", length(c)),
rep("10", length(d)),
rep("100", length(e)))
require(ggplot2)
final <- as.data.frame(cbind(dose,activity))
write.csv(final, "~/Documents/daphnialab/cleaned.csv")
cleaned <- read.csv("~/Documents/daphnialab/cleaned.csv")
rm(list=setdiff(ls(), "cleaned"))
cleaned$dose<-as.factor(cleaned$dose)
p <- ggplot(cleaned, aes(dose, activity))
Calibration <- read.csv(
"~/Documents/daphnialab/Analysed Raw Data/Concat/Calibration.csv",
header = TRUE)
calibrationDataPlot <- ggplot(Calibration, aes(x = Disp, y = X))
calibrationPointShape <- geom_point(shape = 3)
calibrationX_AxisLable <- xlab(
"Calibration Fiber Displacement (pixels)")
calibrationY_AxisLable <- ylab(expression(paste(
"Force Applied on Fiber (",mu,N,")")))
calibrationRegressionLine <- stat_smooth(mapping = NULL, data = NULL,
geom = "smooth", position = "identity",
method = "lm", formula = y ~ x + 0,
se = TRUE, n = 100, fullrange = FALSE,
level = 0.95, na.rm = FALSE)
calibrationDataPlot + calibrationPointShape + calibrationX_AxisLable + calibrationY_AxisLable + calibrationRegressionLine
swimDataPlot <- ggplot(cleaned, aes(dose, activity))
swimBoxPlot <- geom_boxplot(aes(fill = dose),outlier.shape = 1,
outlier.size = 1.5, notch = FALSE,
width = 1)
swimX_Lable <- xlab(expression(paste(
"A-68930 Concentration (",mu,M,")")))
swimY_Lable <- ylab(expression(paste(
"Swimming Force (",mu,N,")")))
swimTheme <- theme(legend.position="none")
swimDataPlot + swimBoxPlot + swimX_Lable + swimY_Lable + swimTheme
20*0.0518
